<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–§–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç –∫–ª–∏–∫–∞</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #hud { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; z-index: 200; }
        #boss-health { position: absolute; top: 10px; right: 10px; color: white; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; display: none; }
        #debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: black;
            color: #0f0;
            padding: 10px;
            border-radius: 8px;
            z-index: 1000;
            font-size: 12px;
            max-height: 200px;
            overflow: auto;
            border: 2px solid #0f0;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="hud">üí∞ <span id="gold">0</span> ‚ú® <span id="exp">0</span><br>–£—Ä–æ–≤–µ–Ω—å <span id="level">1</span></div>
    <div id="boss-health"><span id="boss-name"></span> <span id="boss-current-health">0</span>/<span id="boss-max-health">0</span></div>
    <div id="debug-info"></div>

    <script type="module">
        const API_BASE_URL = 'https://telegram-clicker-bot-zi6c.onrender.com';
        const BOSS_IDS = ['goblin_king', 'dragon_lair', 'lich_castle'];
        const BOSS_NAMES = {
            'goblin_king': '–ö–æ—Ä–æ–ª—å –≥–æ–±–ª–∏–Ω–æ–≤',
            'dragon_lair': '–û–≥–Ω–µ–Ω–Ω—ã–π –¥—Ä–∞–∫–æ–Ω',
            'lich_castle': '–ê—Ä—Ö–∏–ª–∏—á'
        };
        let currentBossId = BOSS_IDS[0];
        let scene, camera, renderer, controls;
        let bossGroup = null;
        let THREE;

        const debugInfo = document.getElementById('debug-info');
        function debugLog(msg) {
            debugInfo.innerHTML += new Date().toLocaleTimeString() + ': ' + msg + '<br>';
            console.log(msg);
        }

        // --- –¢–ï–õ–ï–ì–†–ê–ú ---
        let tg;
        try { tg = window.Telegram.WebApp; tg.ready(); tg.expand(); } catch (e) { tg = { initData: '' }; }
        const initData = tg.initData;
        debugLog('initData: ' + (initData ? initData.substring(0,50) + '...' : '–Ω–µ—Ç'));

        async function apiCall(endpoint) {
            const headers = { 'Content-Type': 'application/json' };
            if (initData) headers['X-Telegram-Init-Data'] = initData;
            try {
                const res = await fetch(`${API_BASE_URL}/api/${endpoint}`, { headers });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                return await res.json();
            } catch (e) {
                debugLog(`–û—à–∏–±–∫–∞ API: ${e.message}`);
                return null;
            }
        }

        // --- –ú–û–î–ï–õ–¨ –ë–û–°–°–ê (–ü–†–û–°–¢–û–ô –†–û–ó–û–í–´–ô –ö–£–ë –° –ú–ï–¢–ö–û–ô) ---
        function createBossModel() {
            debugLog('createBossModel');
            const group = new THREE.Group();
            const geom = new THREE.BoxGeometry(2, 2, 2);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff69b4 }); // —Ä–æ–∑–æ–≤—ã–π
            const cube = new THREE.Mesh(geom, mat);
            cube.userData.isBossPart = true; // –∫–ª—é—á–µ–≤–∞—è –º–µ—Ç–∫–∞
            group.add(cube);
            return group;
        }

        async function loadBossInfo(bid) {
            const data = await apiCall(`boss/${bid}`);
            if (data) {
                document.getElementById('boss-name').textContent = BOSS_NAMES[bid] || bid;
                document.getElementById('boss-current-health').textContent = data.current_health;
                document.getElementById('boss-max-health').textContent = data.max_health;
                document.getElementById('boss-health').style.display = 'block';
            }
        }

        async function attackBoss() {
            debugLog('attackBoss called');
            const data = await apiCall('boss/attack', 'POST', { boss_id: currentBossId });
            if (data) {
                debugLog('attack response: ' + JSON.stringify(data));
                if (data.new_gold !== undefined) document.getElementById('gold').textContent = data.new_gold;
                if (data.new_exp !== undefined) document.getElementById('exp').textContent = data.new_exp;
                if (data.current_health !== undefined) {
                    document.getElementById('boss-current-health').textContent = data.current_health;
                }
            }
        }

        async function init3D() {
            debugLog('init3D started');
            const THREE_IMPORT = await import('three');
            THREE = THREE_IMPORT;
            const { OrbitControls } = await import('https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);

            camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
            camera.position.set(2, 3, 5);
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 2, 0);

            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambient = new THREE.AmbientLight(0x404060);
            scene.add(ambient);
            const light1 = new THREE.DirectionalLight(0xffffff, 1);
            light1.position.set(2, 5, 3);
            scene.add(light1);

            // –ü–æ–ª
            const gridHelper = new THREE.GridHelper(10, 10, 0xaaaaaa, 0x444444);
            scene.add(gridHelper);

            // –ö–†–ê–°–ù–´–ô –ö–£–ë-–ú–ê–Ø–ö (–¥–ª—è –æ—Ä–∏–µ–Ω—Ç–∏—Ä–∞)
            const redCube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            redCube.position.set(0, 4, 0);
            scene.add(redCube);
            debugLog('üî¥ –ö—Ä–∞—Å–Ω—ã–π –∫—É–± –Ω–∞ –≤—ã—Å–æ—Ç–µ 4');

            // –ì–†–£–ü–ü–ê –ë–û–°–°–ê
            bossGroup = new THREE.Group();
            scene.add(bossGroup);

            const bossModel = createBossModel();
            bossGroup.add(bossModel);
            bossGroup.position.set(0, 2, 0);
            debugLog('–ì—Ä—É–ø–ø–∞ –±–æ—Å—Å–∞ –≤ (0,2,0)');

            // –†—ç–π–∫–∞—Å—Ç–µ—Ä
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            function onClick(event) {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([bossGroup.children, redCube]);

                if (intersects.length > 0) {
                    const hit = intersects[0].object;
                    debugLog(`Hit object, isBossPart: ${hit.userData.isBossPart}`);
                    if (hit.userData.isBossPart) {
                        attackBoss();
                    } else if (hit === redCube) {
                        debugLog('–ö–ª–∏–∫ –ø–æ –∫—Ä–∞—Å–Ω–æ–º—É –∫—É–±—É');
                    }
                } else {
                    debugLog('No intersection');
                }
            }

            renderer.domElement.addEventListener('click', onClick);
            renderer.domElement.addEventListener('touchstart', (e) => { e.preventDefault(); onClick(e.touches[0]); }, { passive: false });

            function animate() {
                if (bossGroup) bossGroup.rotation.y += 0.01;
                controls.update();
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
            animate();

            loadBossInfo('goblin_king');
        }

        init3D();
    </script>
</body>
</html>
