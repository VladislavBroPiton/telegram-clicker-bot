<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–®–∞—Ö—Ç—ë—Ä—Å–∫–∞—è –≥–ª—É–±–∏–Ω–∞ 3D</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* –°—Ç–∏–ª–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <!-- –†–∞–∑–º–µ—Ç–∫–∞ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π -->
    <div id="hud">...</div>
    <div id="boss-health">...</div>
    <div id="craft-menu">...</div>
    <div id="toast" class="toast"></div>
    <div id="debug-info"></div>

    <script type="module">
        // --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---
        const API_BASE_URL = 'https://telegram-clicker-bot-zi6c.onrender.com';
        const EXP_PER_LEVEL = 100;
        const BOSS_IDS = ['goblin_king', 'dragon_lair', 'lich_castle'];
        const BOSS_NAMES = {
            'goblin_king': '–ö–æ—Ä–æ–ª—å –≥–æ–±–ª–∏–Ω–æ–≤',
            'dragon_lair': '–û–≥–Ω–µ–Ω–Ω—ã–π –¥—Ä–∞–∫–æ–Ω',
            'lich_castle': '–ê—Ä—Ö–∏–ª–∏—á'
        };

        const TOOL_NAMES = {
            'wooden': '–î–µ—Ä–µ–≤—è–Ω–Ω–∞—è –∫–∏—Ä–∫–∞',
            'stone': '–ö–∞–º–µ–Ω–Ω–∞—è –∫–∏—Ä–∫–∞',
            'iron': '–ñ–µ–ª–µ–∑–Ω–∞—è –∫–∏—Ä–∫–∞',
            'gold': '–ó–æ–ª–æ—Ç–∞—è –∫–∏—Ä–∫–∞',
            'diamond': '–ê–ª–º–∞–∑–Ω–∞—è –∫–∏—Ä–∫–∞',
            'mithril': '–ú–∏—Ñ—Ä–∏–ª–æ–≤–∞—è –∫–∏—Ä–∫–∞'
        };

        const RESOURCE_ICONS = {
            'coal': '‚ö´',
            'iron': '‚öôÔ∏è',
            'gold': 'ü™ô',
            'diamond': 'üíé',
            'mithril': 'üîÆ',
            'soul_shard': 'üíÄ',
            'dragon_scale': 'üêâ',
            'magic_essence': '‚ú®'
        };

        const CRIT_PHRASES = ["üí• –ö–†–ò–¢!", "‚ö° –°–í–ï–†–•–£–î–ê–†!", "üî• –û–ì–û–ù–¨!", "‚ú® –£–î–ê–ß–ê!"];
        const RARE_FIND_PHRASES = {
            'diamond': ['üíé –ê–ª–º–∞–∑!', 'üíé –ë—Ä–∏–ª–ª–∏–∞–Ω—Ç!'],
            'mithril': ['üîÆ –ú–∏—Ñ—Ä–∏–ª!', 'üîÆ –õ–µ–≥–µ–Ω–¥–∞—Ä–Ω—ã–π –º–µ—Ç–∞–ª–ª!'],
            'soul_shard': ['üíÄ –û—Å–∫–æ–ª–æ–∫ –¥—É—à–∏!', 'üíÄ –ñ—É—Ç–∫–∞—è –Ω–∞—Ö–æ–¥–∫–∞!'],
            'dragon_scale': ['üêâ –ß–µ—à—É—è –¥—Ä–∞–∫–æ–Ω–∞!', 'üêâ –î—Ä–∞–∫–æ–Ω—å—è —á–µ—à—É—è!'],
            'magic_essence': ['‚ú® –≠—Å—Å–µ–Ω—Ü–∏—è –º–∞–≥–∏–∏!', '‚ú® –ú–∞–≥–∏—á–µ—Å–∫–∞—è —Å—É–±—Å—Ç–∞–Ω—Ü–∏—è!']
        };

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let currentBossIndex = 0;
        let currentBossId = BOSS_IDS[0];
        let isAttacking = false;
        let resourceObjects = [];
        let scene, camera, renderer, controls;
        let bossGroup = null;
        let threeReady = false;
        let THREE;
        let stars = [];
        let bossCollider = null;
        let environmentObjects = [];
        let torchLights = [];
        let lavaPlane = null;
        let lavaTexture = null;
        let sparkParticles = null;
        let soulParticles = null;
        let floatingBooks = [];
        let ashParticles = null;
        let waterDrops = null;
        let heatDistortion = null;
        let flyingSkulls = [];
        let bubbleParticles = null;
        let runeLights = [];

        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
        const hudLevel = document.getElementById('level');
        const hudExp = document.getElementById('exp');
        const hudExpCurrent = document.getElementById('exp-current');
        const goldSpan = document.getElementById('gold');
        const inventorySpan = document.getElementById('inventory');
        const activeToolSpan = document.getElementById('active-tool');
        const bossHealthDiv = document.getElementById('boss-health');
        const bossNameSpan = document.getElementById('boss-name');
        const bossCurrentHealth = document.getElementById('boss-current-health');
        const bossMaxHealth = document.getElementById('boss-max-health');
        const bossHealthFill = document.getElementById('boss-health-fill');
        const bossIndexSpan = document.getElementById('boss-index');
        const craftMenu = document.getElementById('craft-menu');
        const craftContent = document.getElementById('craft-content');
        const closeCraft = document.getElementById('close-craft');
        const craftBtn = document.getElementById('craft-btn');
        const toast = document.getElementById('toast');
        const debugInfo = document.getElementById('debug-info');

        function debugLog(msg) {
            console.log(msg);
        }

        // --- –¢–ï–õ–ï–ì–†–ê–ú ---
        let tg;
        try {
            tg = window.Telegram.WebApp;
            tg.ready();
            tg.expand();
        } catch (e) {
            tg = { initData: '' };
        }
        const initData = tg.initData;
        debugLog('initData: ' + (initData ? initData.substring(0,50) + '...' : '–Ω–µ—Ç'));

        // --- API ---
        async function apiCall(endpoint, method = 'GET', body = null) {
            const headers = { 'Content-Type': 'application/json' };
            if (initData) headers['X-Telegram-Init-Data'] = initData;
            const options = { method, headers };
            if (body) options.body = JSON.stringify(body);
            try {
                const response = await fetch(`${API_BASE_URL}/api/${endpoint}`, options);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response.json();
            } catch (e) {
                debugLog(`–û—à–∏–±–∫–∞ API ${endpoint}: ${e.message}`);
                return null;
            }
        }

        function updateExpBar(level, exp) {
            hudLevel.textContent = level;
            hudExp.textContent = exp;
            hudExpCurrent.textContent = exp;
        }

        function updateInventoryDisplay(inv) {
            if (!inv) { inventorySpan.textContent = '‚Äî'; return; }
            const entries = Object.entries(inv).filter(([,v]) => v > 0);
            if (entries.length === 0) {
                inventorySpan.textContent = '–ø—É—Å—Ç–æ';
                return;
            }
            const parts = entries.map(([res, count]) => {
                const icon = RESOURCE_ICONS[res] || '‚ùì';
                return `${icon} ${count}`;
            });
            inventorySpan.textContent = parts.join('  ');
        }

        function updateBossHealth(current, max) {
            bossCurrentHealth.textContent = current;
            bossMaxHealth.textContent = max;
            bossHealthFill.style.width = (max ? (current / max) * 100 : 0) + '%';
        }

        function showToast(message, duration = 2000) {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), duration);
        }

        function hapticFeedback(style = 'light') {
            if (tg && tg.HapticFeedback) {
                tg.HapticFeedback.impactOccurred(style);
            }
        }

        // --- –ó–í–Å–ó–î–ù–û–ï –ù–ï–ë–û ---
        function createStars() {
            if (!THREE) return;
            const geometry = new THREE.SphereGeometry(100, 32, 16);
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 2 + 1;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.fillStyle = 'rgba(100,50,150,0.1)';
            for (let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.arc(Math.random()*canvas.width, Math.random()*canvas.height, Math.random()*50+20, 0, 2*Math.PI);
                ctx.fill();
            }
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });
            const skySphere = new THREE.Mesh(geometry, material);
            scene.add(skySphere);
            stars.push(skySphere);
        }

        // --- –í–ò–ó–£–ê–õ–¨–ù–ê–Ø –ú–û–î–ï–õ–¨ –ë–û–°–°–ê (–ü–û–õ–ù–û–°–¢–¨–Æ) ---
        function createVisualBossModel(bossId) {
            const group = new THREE.Group();

            if (bossId === 'goblin_king') {
                // ... (–≤–µ—Å—å –∫–æ–¥ –≥–æ–±–ª–∏–Ω–∞, –∫–∞–∫ –≤ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –≤–µ—Ä—Å–∏—è—Ö)
                // –î–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏ —è –Ω–µ –±—É–¥—É –µ–≥–æ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å, –Ω–æ –æ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–¥–µ—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é.
                // –í –≤–∞—à–µ–º —Ñ–∞–π–ª–µ –æ–Ω —É–∂–µ –µ—Å—Ç—å.
            } else if (bossId === 'dragon_lair') {
                // ... –∫–æ–¥ –¥—Ä–∞–∫–æ–Ω–∞
            } else if (bossId === 'lich_castle') {
                // ... –∫–æ–¥ –ª–∏—á–∞
            }

            group.scale.set(0.8, 0.8, 0.8);
            group.position.y = 1.5;
            return group;
        }

        // ========== –§–£–ù–ö–¶–ò–ò –°–û–ó–î–ê–ù–ò–Ø –ö–õ–ò–ö–ê–ë–ï–õ–¨–ù–´–• –û–ë–™–ï–ö–¢–û–í (–£–í–ï–õ–ò–ß–ï–ù–ù–´–ï –ò –Ø–†–ö–ò–ï) ==========
        function createGoldBag() {
            console.log('–°–æ–∑–¥–∞—ë–º –º–µ—à–æ–∫ —Å –∑–æ–ª–æ—Ç–æ–º');
            const group = new THREE.Group();
            const bagMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 }); // —è—Ä–∫–∏–π
            const bag = new THREE.Mesh(new THREE.SphereGeometry(1.2, 16), bagMat);
            bag.scale.set(1.0, 0.8, 1.0);
            bag.position.y = 0.8;
            group.add(bag);

            const ropeMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const rope = new THREE.Mesh(new THREE.TorusGeometry(0.9, 0.1, 8, 24), ropeMat);
            rope.rotation.x = Math.PI / 2;
            rope.position.y = 1.2;
            group.add(rope);

            const coinMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 });
            for (let i = 0; i < 3; i++) {
                const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8), coinMat);
                coin.position.set(0.4 * Math.sin(i), 1.5 + i * 0.1, 0.4 * Math.cos(i));
                coin.rotation.x = Math.random() * Math.PI;
                coin.rotation.z = Math.random() * Math.PI;
                group.add(coin);
            }
            return group;
        }

        function createGoldBar() {
            console.log('–°–æ–∑–¥–∞—ë–º –∑–æ–ª–æ—Ç–æ–π —Å–ª–∏—Ç–æ–∫');
            const group = new THREE.Group();
            const barMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, metalness: 0.9, roughness: 0.3, emissive: 0x442200 });
            const bar = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 0.8), barMat);
            bar.position.y = 0.3;
            group.add(bar);
            const digitMat = new THREE.MeshStandardMaterial({ color: 0xcc8800 });
            const digit = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.1, 0.2), digitMat);
            digit.position.set(0.4, 0.5, 0.2);
            group.add(digit);
            return group;
        }

        function createCoinPile() {
            console.log('–°–æ–∑–¥–∞—ë–º –∫—É—á—É –º–æ–Ω–µ—Ç');
            const group = new THREE.Group();
            const coinMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 });
            for (let i = 0; i < 12; i++) {
                const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8), coinMat);
                coin.position.set(Math.sin(i)*0.7, 0.2 + i*0.06, Math.cos(i)*0.7);
                coin.rotation.x = Math.random() * Math.PI;
                coin.rotation.z = Math.random() * Math.PI;
                group.add(coin);
            }
            return group;
        }

        function createGem() {
            console.log('–°–æ–∑–¥–∞—ë–º –¥—Ä–∞–≥–æ—Ü–µ–Ω–Ω—ã–π –∫–∞–º–µ–Ω—å');
            const gemMat = new THREE.MeshStandardMaterial({ color: 0xff44aa, emissive: 0x331122, transparent: true, opacity: 0.8 });
            const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.7), gemMat);
            return gem;
        }

        function createBone() {
            console.log('–°–æ–∑–¥–∞—ë–º –∫–æ—Å—Ç—å');
            const group = new THREE.Group();
            const boneMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1.5), boneMat);
            shaft.rotation.z = 0.2;
            shaft.position.y = 0.8;
            group.add(shaft);
            const end1 = new THREE.Mesh(new THREE.SphereGeometry(0.3), boneMat);
            end1.position.set(0.2, 1.5, 0);
            group.add(end1);
            const end2 = new THREE.Mesh(new THREE.SphereGeometry(0.3), boneMat);
            end2.position.set(-0.2, 0.1, 0);
            group.add(end2);
            return group;
        }

        function createDragonEgg() {
            console.log('–°–æ–∑–¥–∞—ë–º –¥—Ä–∞–∫–æ–Ω—å–µ —è–π—Ü–æ');
            const group = new THREE.Group();
            const eggMat = new THREE.MeshStandardMaterial({ color: 0xaa4422, emissive: 0x331100 });
            const egg = new THREE.Mesh(new THREE.SphereGeometry(1.2, 16), eggMat);
            egg.scale.set(1.0, 1.3, 1.0);
            egg.position.y = 0.9;
            group.add(egg);
            const scaleMat = new THREE.MeshStandardMaterial({ color: 0xcc5533 });
            for (let i = 0; i < 8; i++) {
                const s = new THREE.Mesh(new THREE.SphereGeometry(0.2, 4), scaleMat);
                s.position.set(Math.sin(i)*0.8, 0.9 + Math.cos(i*2)*0.4, Math.cos(i)*0.8);
                group.add(s);
            }
            return group;
        }

        function createVolcanicCrystal() {
            console.log('–°–æ–∑–¥–∞—ë–º –≤—É–ª–∫–∞–Ω–∏—á–µ—Å–∫–∏–π –∫—Ä–∏—Å—Ç–∞–ª–ª');
            const group = new THREE.Group();
            const crystalMat = new THREE.MeshStandardMaterial({ color: 0xff3300, emissive: 0x441100, transparent: true, opacity: 0.7 });
            const crystal = new THREE.Mesh(new THREE.DodecahedronGeometry(0.9), crystalMat);
            group.add(crystal);
            for (let i = 0; i < 4; i++) {
                const small = new THREE.Mesh(new THREE.OctahedronGeometry(0.3), crystalMat);
                small.position.set(0.9*Math.sin(i), 0.4, 0.9*Math.cos(i));
                group.add(small);
            }
            return group;
        }

        function createObsidianRock() {
            console.log('–°–æ–∑–¥–∞—ë–º –æ–±—Å–∏–¥–∏–∞–Ω–æ–≤—É—é –≥–ª—ã–±—É');
            const rockMat = new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0x220000 });
            const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(1.0), rockMat);
            return rock;
        }

        function createSoul() {
            console.log('–°–æ–∑–¥–∞—ë–º –¥—É—à—É');
            const group = new THREE.Group();
            const soulMat = new THREE.MeshStandardMaterial({ color: 0x88aaff, emissive: 0x224466, transparent: true, opacity: 0.7 });
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8), soulMat);
            group.add(sphere);
            const particleCount = 8;
            const particleGeom = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                positions[i*3] = Math.cos(angle) * 1.2;
                positions[i*3+1] = Math.sin(angle) * 0.4;
                positions[i*3+2] = Math.sin(angle) * 1.2;
            }
            particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMat = new THREE.PointsMaterial({ color: 0xaaccff, size: 0.2 });
            const particles = new THREE.Points(particleGeom, particleMat);
            group.add(particles);
            return group;
        }

        function createFloatingBook() {
            console.log('–°–æ–∑–¥–∞—ë–º –∫–Ω–∏–≥—É');
            const group = new THREE.Group();
            const coverMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const cover = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 1.2), coverMat);
            cover.position.y = 0;
            group.add(cover);
            const pagesMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const pages = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.4, 1.0), pagesMat);
            pages.position.y = 0.25;
            group.add(pages);
            const runeMat = new THREE.MeshStandardMaterial({ color: 0xaa88ff, emissive: 0x331166 });
            for (let i = 0; i < 3; i++) {
                const rune = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.1, 0.2), runeMat);
                rune.position.set(0.4, 0.45, 0.4 * i - 0.4);
                group.add(rune);
            }
            return group;
        }

        function createVial() {
            console.log('–°–æ–∑–¥–∞—ë–º –∫–æ–ª–±—É');
            const group = new THREE.Group();
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x88aaff, transparent: true, opacity: 0.4, emissive: 0x112244 });
            const glass = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16), glassMat);
            glass.scale.set(1.0, 1.3, 1.0);
            glass.position.y = 0.7;
            group.add(glass);
            const liquidMat = new THREE.MeshStandardMaterial({ color: 0x44aaff, emissive: 0x113366 });
            const liquid = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8), liquidMat);
            liquid.scale.set(1.0, 1.0, 1.0);
            liquid.position.y = 0.7;
            group.add(liquid);
            const corkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const cork = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.4), corkMat);
            cork.position.y = 1.3;
            group.add(cork);
            return group;
        }

        function createSkull() {
            console.log('–°–æ–∑–¥–∞—ë–º —á–µ—Ä–µ–ø');
            const group = new THREE.Group();
            const boneMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8), boneMat);
            head.scale.set(0.9, 0.8, 0.9);
            head.position.y = 0.6;
            group.add(head);
            const jaw = new THREE.Mesh(new THREE.SphereGeometry(0.6, 6), boneMat);
            jaw.scale.set(0.8, 0.5, 0.7);
            jaw.position.set(0, 0.1, 0.4);
            group.add(jaw);
            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshStandardMaterial({ color: 0x000000 }));
            eye1.position.set(-0.3, 0.9, 0.5);
            group.add(eye1);
            const eye2 = eye1.clone();
            eye2.position.set(0.3, 0.9, 0.5);
            group.add(eye2);
            return group;
        }

        function createDarkCrystal() {
            console.log('–°–æ–∑–¥–∞—ë–º —Ç—ë–º–Ω—ã–π –∫—Ä–∏—Å—Ç–∞–ª–ª');
            const crystalMat = new THREE.MeshStandardMaterial({ color: 0x8822aa, emissive: 0x331144, transparent: true, opacity: 0.8 });
            const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(1.0), crystalMat);
            return crystal;
        }

        // --- –§–£–ù–ö–¶–ò–Ø –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ (—Å –æ—Ç–ª–∞–¥–∫–æ–π) ---
        function createResourceObjectsForBoss(bossId) {
            resourceObjects.forEach(obj => scene.remove(obj));
            resourceObjects = [];

            const positions = [
                [-3, 2.5, -2],
                [3, 2.5, -2],
                [0, 2.5, 2],
                [-2, 2.5, 3],
                [2, 2.5, 3]
            ];

            let creators = [];
            if (bossId === 'goblin_king') {
                creators = [createGoldBag, createGoldBar, createCoinPile, createGem, createBone];
            } else if (bossId === 'dragon_lair') {
                creators = [createDragonEgg, createVolcanicCrystal, createObsidianRock, createGoldBar, createBone];
            } else if (bossId === 'lich_castle') {
                creators = [createSoul, createFloatingBook, createVial, createSkull, createDarkCrystal];
            } else {
                creators = [createGoldBag, createGoldBar, createCoinPile, createGem, createBone];
            }

            console.log(`–°–æ–∑–¥–∞—ë–º –æ–±—ä–µ–∫—Ç—ã –¥–ª—è –±–æ—Å—Å–∞ ${bossId}, –≤—Å–µ–≥–æ ${creators.length} –æ–±—ä–µ–∫—Ç–æ–≤`);

            for (let i = 0; i < creators.length; i++) {
                const obj = creators[i]();
                if (obj) {
                    obj.position.set(positions[i][0], positions[i][1], positions[i][2]);
                    obj.userData = { type: 'resource', id: i };
                    scene.add(obj);
                    resourceObjects.push(obj);
                    console.log(`–û–±—ä–µ–∫—Ç ${i} –¥–æ–±–∞–≤–ª–µ–Ω –Ω–∞ –ø–æ–∑–∏—Ü–∏—é ${positions[i]}`);
                } else {
                    console.error(`–§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞ ${i} –≤–µ—Ä–Ω—É–ª–∞ null/undefined`);
                }
            }
        }

        // --- –û–ß–ò–°–¢–ö–ê –û–ö–†–£–ñ–ï–ù–ò–Ø ---
        function clearEnvironment() {
            // ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        }

        // --- –£–õ–£–ß–®–ï–ù–ù–´–ï –î–ï–ö–û–†–ê–¶–ò–ò –î–õ–Ø –õ–û–ö–ê–¶–ò–ô –ë–û–°–°–û–í (–ü–û–õ–ù–û–°–¢–¨–Æ) ---
        function createEnvironmentForBoss(bossId) {
            // ... (–≤–µ—Å—å –∫–æ–¥ –¥–µ–∫–æ—Ä–∞—Ü–∏–π –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ —Ñ–∞–π–ª–∞)
        }

        // --- –ó–ê–ì–†–£–ó–ö–ê –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø ---
        async function loadUser() {
            // ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        }

        // --- –ó–ê–ì–†–£–ó–ö–ê –ò–ù–§–û–†–ú–ê–¶–ò–ò –û –ë–û–°–°–ï ---
        async function loadBossInfo(bid) {
            // ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        }

        // --- –ù–ê–í–ò–ì–ê–¶–ò–Ø –ü–û –ë–û–°–°–ê–ú ---
        function updateBossNavigation() {
            // ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        }

        document.getElementById('prev-boss').addEventListener('click', () => {
            // ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        });

        document.getElementById('next-boss').addEventListener('click', () => {
            // ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        });

        // --- –ß–ê–°–¢–ò–¶–´ –ü–†–ò –£–î–ê–†–ï ---
        function createHitParticles(position) {
            // ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        }

        // --- –í–°–ü–õ–´–í–ê–Æ–©–ò–ô –¢–ï–ö–°–¢ –£–†–û–ù–ê ---
        function showDamageText(damage, position) {
            // ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        }

        // --- –ê–¢–ê–ö–ê –ë–û–°–°–ê ---
        async function attackBoss() {
            // ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        }

        // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø 3D ---
        async function init3D() {
            debugLog('init3D started');
            try {
                const THREE_IMPORT = await import('three');
                THREE = THREE_IMPORT;
                const { OrbitControls } = await import('https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js');

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a20);

                camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
                camera.position.set(2, 3, 5);
                camera.lookAt(0, 2, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(innerWidth, innerHeight);
                document.body.appendChild(renderer.domElement);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.target.set(0, 2, 0);
                controls.update();

                const ambient = new THREE.AmbientLight(0x404060);
                scene.add(ambient);
                const light1 = new THREE.DirectionalLight(0xffffff, 1.2);
                light1.position.set(5, 10, 7);
                scene.add(light1);
                const light2 = new THREE.DirectionalLight(0xffaa88, 0.8);
                light2.position.set(-5, 5, -5);
                scene.add(light2);

                createStars();

                // –ì—Ä—É–ø–ø–∞ –¥–ª—è –±–æ—Å—Å–∞
                bossGroup = new THREE.Group();
                scene.add(bossGroup);

                const visualBoss = createVisualBossModel(currentBossId);
                bossGroup.add(visualBoss);

                const colliderGeom = new THREE.SphereGeometry(2.5, 8);
                const colliderMat = new THREE.MeshBasicMaterial({ visible: false });
                const collider = new THREE.Mesh(colliderGeom, colliderMat);
                collider.position.set(0, 1.5, 0);
                collider.userData.isBossPart = true;
                bossGroup.add(collider);
                bossCollider = collider;

                bossGroup.position.set(0, 2, 0);

                createEnvironmentForBoss(currentBossId);
                createResourceObjectsForBoss(currentBossId);

                threeReady = true;
                debugLog('Three.js –≥–æ—Ç–æ–≤');

                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                function handleClick(event) {
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);

                    // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
                    const resourceIntersects = raycaster.intersectObjects(resourceObjects);
                    if (resourceIntersects.length > 0) {
                        const hit = resourceIntersects[0].object;
                        debugLog(`Hit resource: ${JSON.stringify(hit.userData)}`);

                        hapticFeedback('light');
                        const originalScale = hit.scale.clone();
                        hit.scale.set(0.8, 0.8, 0.8);
                        setTimeout(() => hit.scale.copy(originalScale), 100);
                        createHitParticles(hit.position.clone());

                        if (hit.material) {
                            const originalEmissive = hit.material.emissive ? hit.material.emissive.clone() : null;
                            hit.material.emissive.setHex(0xffaa22);
                            setTimeout(() => {
                                if (originalEmissive) hit.material.emissive.copy(originalEmissive);
                                else hit.material.emissive.setHex(0x000000);
                            }, 150);
                        }

                        apiCall('click', 'POST', { resourceId: hit.userData.id }).then(data => {
                            if (data) {
                                goldSpan.textContent = data.new_gold;
                                hudExp.textContent = data.new_exp;
                                updateInventoryDisplay(data.inventory);
                                loadUser();

                                let phrase = '';
                                if (data.is_crit) {
                                    phrase = CRIT_PHRASES[Math.floor(Math.random() * CRIT_PHRASES.length)];
                                } else if (data.found_resource && RARE_FIND_PHRASES[data.found_resource]) {
                                    const arr = RARE_FIND_PHRASES[data.found_resource];
                                    phrase = arr[Math.floor(Math.random() * arr.length)];
                                }
                                if (phrase) showToast(phrase, 1000);
                            }
                        });
                        return;
                    }

                    // –ó–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä—è–µ–º –±–æ—Å—Å–∞
                    const bossIntersects = raycaster.intersectObjects(bossGroup.children);
                    if (bossIntersects.length > 0) {
                        const hit = bossIntersects[0].object;
                        if (hit.userData.isBossPart) {
                            debugLog('‚úÖ –≠—Ç–æ —á–∞—Å—Ç—å –±–æ—Å—Å–∞ (–∫–æ–ª–ª–∞–π–¥–µ—Ä)!');
                            attackBoss();
                        }
                    }
                }

                renderer.domElement.addEventListener('click', handleClick);
                renderer.domElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleClick(e.touches[0]);
                }, { passive: false });

                // –ê–Ω–∏–º–∞—Ü–∏—è
                let time = 0;
                function animate() {
                    time += 0.01;

                    resourceObjects.forEach((obj, idx) => {
                        // –í—Ä–∞—â–µ–Ω–∏–µ –¥–ª—è –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤
                        if (obj.geometry && (obj.geometry.type === 'OctahedronGeometry' || obj.geometry.type === 'DodecahedronGeometry')) {
                            obj.rotation.y += 0.01;
                        }
                        // –ü—É–ª—å—Å–∞—Ü–∏—è –¥–ª—è –¥—É—à –∏ —è–∏—Ü
                        if (currentBossId === 'lich_castle' && idx === 0) {
                            const scale = 1 + Math.sin(time * 5) * 0.1;
                            obj.scale.set(scale, scale, scale);
                        }
                        if (currentBossId === 'dragon_lair' && idx === 0) {
                            const scale = 1 + Math.sin(time * 4) * 0.05;
                            obj.scale.set(scale, scale, scale);
                        }
                    });

                    if (bossGroup && bossGroup.children.length > 0) {
                        bossGroup.rotation.y += 0.005;
                    }

                    // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏ (–±–æ—Å—Å–æ–≤, –ª–∞–≤—ã –∏ —Ç.–¥.) –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ...

                    controls.update();
                    renderer.render(scene, camera);
                    requestAnimationFrame(animate);
                }
                animate();

                window.addEventListener('resize', () => {
                    camera.aspect = innerWidth/innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(innerWidth, innerHeight);
                });

                loadUser();

            } catch (e) {
                debugLog(`‚ùå –û—à–∏–±–∫–∞ –≤ init3D: ${e.message}`);
            }
        }

        // --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫—Ä–∞—Ñ—Ç–∞ ---
        function openCraftMenu() {
            // ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        }

        window.craftItem = function(itemName) {
            // ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        };

        closeCraft.addEventListener('click', () => craftMenu.style.display = 'none');
        craftBtn.addEventListener('click', openCraftMenu);

        // --- –°–¢–ê–†–¢ ---
        init3D();
    </script>
</body>
</html>
