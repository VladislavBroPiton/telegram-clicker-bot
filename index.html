<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–®–∞—Ö—Ç—ë—Ä—Å–∫–∞—è –≥–ª—É–±–∏–Ω–∞ 3D</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; touch-action: none; }

/* –û–±—â–∏–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã */
#hud, #boss-health {
    position: absolute;
    color: white;
    background: rgba(20, 20, 30, 0.85);
    backdrop-filter: blur(4px);
    padding: 10px 14px;
    border-radius: 16px;
    z-index: 200;
    pointer-events: none;
    border: 1px solid rgba(255,215,0,0.3);
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    font-size: 14px;
    transition: all 0.2s;
}

#hud {
    top: 10px;
    left: 10px;
    right: auto;
    max-width: calc(100% - 240px);
}

#boss-health {
    top: 10px;
    right: 10px;
    width: 220px;
    display: none;
    border-color: #ff4444;
}

/* –î–ª—è —É–∑–∫–∏—Ö —ç–∫—Ä–∞–Ω–æ–≤ (–º–æ–±–∏–ª—å–Ω—ã–µ) */
@media (max-width: 600px) {
    #hud {
        max-width: none;
        right: 10px;
        width: auto;
        margin-bottom: 5px;
    }
    #boss-health {
        top: auto;
        bottom: 10px; /* –ø–∞–Ω–µ–ª—å –±–æ—Å—Å–∞ –≤–Ω–∏–∑—É */
        right: 10px;
        left: 10px;
        width: auto;
    }
    /* –ü–∞–Ω–µ–ª–∏ –æ—Ç–ª–∞–¥–∫–∏ –ø–æ–¥–Ω–∏–º–∞–µ–º –≤—ã—à–µ, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—Ç—å –ø–∞–Ω–µ–ª—å –±–æ—Å—Å–∞ */
    #debug-info {
        bottom: auto;
        top: 70px;
        max-height: calc(100% - 200px);
    }
    #error-message {
        bottom: 70px;
        top: auto;
    }
    #success-message {
        bottom: 120px;
        top: auto;
    }
    #loot-message {
        top: 50%;
        transform: translateY(-50%);
    }
}

/* –ï—Å–ª–∏ –æ—á–µ–Ω—å —É–∑–∫–æ, –º–æ–∂–Ω–æ –µ—â—ë —É–º–µ–Ω—å—à–∏—Ç—å –æ—Ç—Å—Ç—É–ø—ã */
@media (max-width: 400px) {
    #hud {
        font-size: 12px;
        padding: 6px 10px;
    }
    #boss-health {
        font-size: 12px;
        padding: 6px 10px;
    }
    #debug-info, #error-message, #success-message, #loot-message {
        font-size: 12px;
        padding: 6px;
    }
}

/* –ü–æ–ª–æ—Å–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è */
.health-bar {
    width: 100%;
    height: 16px;
    background-color: #333;
    border-radius: 8px;
    overflow: hidden;
    margin-top: 6px;
}
.health-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff4444, #ff8844);
    width: 100%;
    transition: width 0.2s;
}

/* –ù–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ –±–æ—Å—Å–∞–º */
.boss-navigation {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 10px;
    pointer-events: auto;
}
.boss-nav-btn {
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    font-size: 20px;
    width: 40px;
    height: 40px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: 0.2s;
}
.boss-nav-btn:active { background: rgba(255,255,255,0.4); }
.boss-nav-btn.disabled { opacity: 0.3; pointer-events: none; }

/* –ü–∞–Ω–µ–ª–∏ –æ—Ç–ª–∞–¥–∫–∏ */
#debug-info, #error-message, #success-message, #loot-message {
    position: absolute;
    left: 10px;
    right: 10px;
    background: rgba(0,0,0,0.9);
    padding: 10px;
    border-radius: 8px;
    z-index: 1000;
    font-size: 14px;
    white-space: pre-wrap;
    word-break: break-word;
    pointer-events: none;
}
#debug-info {
    bottom: 80px;
    border: 2px solid yellow;
    color: white;
    max-height: 150px;
    overflow: auto;
}
#error-message {
    bottom: 10px;
    border: 2px solid red;
    color: #ff8888;
}
#success-message {
    bottom: 60px;
    border: 2px solid #0f0;
    color: #aaffaa;
}
#loot-message {
    top: 50%;
    transform: translateY(-50%);
    background: rgba(0,0,0,0.95);
    border: 2px solid gold;
    color: gold;
    font-size: 18px;
    text-align: center;
    padding: 20px;
    border-radius: 20px;
    box-shadow: 0 0 30px gold;
    display: none;
}

#test-button {
    position: absolute;
    bottom: 10px;
    right: 10px;
    z-index: 2000;
    background: #ff4444;
    color: white;
    padding: 8px 16px;
    border: none;
    border-radius: 20px;
    font-size: 14px;
    font-weight: bold;
    pointer-events: auto;
}

#tool-display {
    margin-top: 8px;
    font-size: 13px;
    color: #ffaa66;
    border-top: 1px solid #444;
    padding-top: 6px;
}
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="hud">
        <div style="display: flex; justify-content: space-between;">
            <span>üí∞ <span id="gold">0</span></span>
            <span>‚ú® <span id="exp">0</span></span>
        </div>
        <div id="exp-bar-container"><div id="exp-bar-fill"></div></div>
        <div id="exp-text">–£—Ä–æ–≤–µ–Ω—å <span id="level">1</span> ‚Ä¢ <span id="exp-current">0</span>/100 –æ–ø—ã—Ç–∞</div>
        <div>üì¶ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å: <span id="inventory">‚Äî</span></div>
        <div id="tool-display">üß∞ –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: <span id="active-tool">–∑–∞–≥—Ä—É–∑–∫–∞...</span></div>
    </div>
    <div id="boss-health">
        <div style="display: flex; justify-content: space-between;">
            <span>üëæ <span id="boss-name"></span></span>
            <span><span id="boss-current-health">0</span>/<span id="boss-max-health">0</span></span>
        </div>
        <div class="health-bar"><div class="health-fill" id="boss-health-fill"></div></div>
        <div class="boss-navigation">
            <button class="boss-nav-btn" id="prev-boss">‚Üê</button>
            <span style="font-size: 14px;" id="boss-index">1/3</span>
            <button class="boss-nav-btn" id="next-boss">‚Üí</button>
        </div>
    </div>
    <div id="debug-info" style="display: none;"></div>
    <div id="error-message" style="display: none;"></div>
    <div id="success-message" style="display: none;"></div>
    <div id="loot-message">üéÅ –ü–û–ë–ï–î–ê!<br><span id="loot-details"></span></div>
    <button id="test-button">–¢–ï–°–¢</button>

    <script type="module">
        // --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
        const API_BASE_URL = 'https://telegram-clicker-bot-zi6c.onrender.com';
        const EXP_PER_LEVEL = 100;

        // –°–ø–∏—Å–æ–∫ –±–æ—Å—Å–æ–≤
        const BOSS_IDS = ['goblin_king', 'dragon_lair', 'lich_castle'];
        const BOSS_NAMES = {
            'goblin_king': '–ö–æ—Ä–æ–ª—å –≥–æ–±–ª–∏–Ω–æ–≤',
            'dragon_lair': '–û–≥–Ω–µ–Ω–Ω—ã–π –¥—Ä–∞–∫–æ–Ω',
            'lich_castle': '–ê—Ä—Ö–∏–ª–∏—á'
        };

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let currentBossIndex = 0;
        let currentBossId = BOSS_IDS[0];
        let isAttacking = false;
        let cubes = [];
        let scene, camera, renderer, controls;
        let bossGroup = null;
        let threeReady = false; // —Ñ–ª–∞–≥ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ Three.js

        // –ê—É–¥–∏–æ
        let audioClick = new Audio('https://github.com/VladislavBroPiton/telegram-clicker-bot/blob/main/creatorshome-pickaxe-blow-333695.mp3');
        let audioBossHit = new Audio('https://github.com/VladislavBroPiton/telegram-clicker-bot/blob/main/creatorshome-pickaxe-blow-333695.mp3');
        let audioVictory = new Audio('https://github.com/VladislavBroPiton/telegram-clicker-bot/blob/main/creatorshome-pickaxe-blow-333695.mp3');
        audioClick.load();
        audioBossHit.load();
        audioVictory.load();

        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
        const hudLevel = document.getElementById('level');
        const hudExp = document.getElementById('exp');
        const hudExpCurrent = document.getElementById('exp-current');
        const expBarFill = document.getElementById('exp-bar-fill');
        const goldSpan = document.getElementById('gold');
        const inventorySpan = document.getElementById('inventory');
        const activeToolSpan = document.getElementById('active-tool');
        const bossHealthDiv = document.getElementById('boss-health');
        const bossNameSpan = document.getElementById('boss-name');
        const bossCurrentHealth = document.getElementById('boss-current-health');
        const bossMaxHealth = document.getElementById('boss-max-health');
        const bossHealthFill = document.getElementById('boss-health-fill');
        const bossIndexSpan = document.getElementById('boss-index');
        const debugInfo = document.getElementById('debug-info');
        const errorMsg = document.getElementById('error-message');
        const successMsg = document.getElementById('success-message');
        const lootMsg = document.getElementById('loot-message');
        const lootDetails = document.getElementById('loot-details');

        // --- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ---
        function debugLog(msg) {
            debugInfo.style.display = 'block';
            debugInfo.innerHTML = msg + '<br>' + debugInfo.innerHTML;
            console.log(msg);
        }

        function showError(msg) {
            errorMsg.style.display = 'block';
            errorMsg.innerHTML = msg;
        }

        function showSuccess(msg) {
            successMsg.style.display = 'block';
            successMsg.innerHTML = msg;
            setTimeout(() => successMsg.style.display = 'none', 2000);
        }

        function showLoot(items) {
            lootDetails.innerHTML = items;
            lootMsg.style.display = 'block';
            setTimeout(() => lootMsg.style.display = 'none', 4000);
        }

        // --- –¢–ï–õ–ï–ì–†–ê–ú ---
        let tg;
        try {
            tg = window.Telegram.WebApp;
            tg.ready();
            tg.expand();
        } catch (e) {
            tg = { ready: () => {}, expand: () => {}, HapticFeedback: { impactOccurred: () => {} }, initData: "" };
        }
        const initData = tg.initData;
        debugLog('initData: ' + (initData ? initData.substring(0,50) + '...' : '–Ω–µ—Ç'));

        // --- API ---
        async function apiCall(endpoint, method = 'GET', body = null) {
            const headers = { 'Content-Type': 'application/json' };
            if (initData) headers['X-Telegram-Init-Data'] = initData;
            const options = { method, headers };
            if (body) options.body = JSON.stringify(body);

            debugLog(`‚û°Ô∏è –ó–∞–ø—Ä–æ—Å ${method} /api/${endpoint} ` + (body ? `—Ç–µ–ª–æ: ${JSON.stringify(body)}` : ''));

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                options.signal = controller.signal;

                const response = await fetch(`${API_BASE_URL}/api/${endpoint}`, options);
                clearTimeout(timeoutId);

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText.substring(0,100)}`);
                }
                const json = await response.json();
                debugLog(`‚úÖ –û—Ç–≤–µ—Ç –æ—Ç ${endpoint}: ${JSON.stringify(json, null, 2)}`);
                return json;
            } catch (e) {
                const errorMsg = `‚ùå –û—à–∏–±–∫–∞ API ${endpoint}: ${e.message}`;
                debugLog(errorMsg);
                showError(errorMsg);
                return null;
            }
        }

        // --- –û–ë–ù–û–í–õ–ï–ù–ò–ï –ò–ù–¢–ï–†–§–ï–ô–°–ê ---
        function updateExpBar(level, exp) {
            hudLevel.textContent = level;
            hudExp.textContent = exp;
            hudExpCurrent.textContent = exp;
            const percent = (exp / EXP_PER_LEVEL) * 100;
            expBarFill.style.width = percent + '%';
        }

        function updateInventoryDisplay(inv) {
            if (!inv) {
                inventorySpan.textContent = '‚Äî';
                return;
            }
            const entries = Object.entries(inv).filter(([,v]) => v > 0);
            if (entries.length === 0) inventorySpan.textContent = '–ø—É—Å—Ç–æ';
            else inventorySpan.textContent = entries.map(([k,v]) => `${k}:${v}`).join(', ');
        }

        function updateBossHealth(current, max) {
            bossCurrentHealth.textContent = current;
            bossMaxHealth.textContent = max;
            const percent = max > 0 ? (current / max) * 100 : 0;
            bossHealthFill.style.width = percent + '%';
        }

        // --- –§–£–ù–ö–¶–ò–Ø –°–û–ó–î–ê–ù–ò–Ø –ú–û–î–ï–õ–ò –ë–û–°–°–ê (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ ready) ---
        function createBossModel(bossId) {
            console.log('createBossModel called for', bossId);
            if (!bossGroup) {
                console.error('bossGroup not ready');
                return null;
            }
            const group = new THREE.Group();

            if (bossId === 'goblin_king') {
                const bodyGeom = new THREE.CylinderGeometry(1.2, 1.5, 2, 8);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0x44aa88, emissive: 0x112233 });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 1;
                group.add(body);

                const headGeom = new THREE.SphereGeometry(0.8, 8);
                const headMat = new THREE.MeshStandardMaterial({ color: 0x88ccaa });
                const head = new THREE.Mesh(headGeom, headMat);
                head.position.y = 2.2;
                group.add(head);

                const crownGeom = new THREE.ConeGeometry(0.6, 0.5, 4);
                const crownMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 });
                const crown = new THREE.Mesh(crownGeom, crownMat);
                crown.position.y = 2.8;
                crown.rotation.y = Math.PI/4;
                group.add(crown);

                const eyeGeom = new THREE.SphereGeometry(0.15);
                const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });

                const eyeL = new THREE.Mesh(eyeGeom, eyeMat);
                eyeL.position.set(-0.3, 2.3, 0.7);
                group.add(eyeL);
                const pupilL = new THREE.Mesh(new THREE.SphereGeometry(0.07), pupilMat);
                pupilL.position.set(-0.3, 2.3, 0.85);
                group.add(pupilL);

                const eyeR = new THREE.Mesh(eyeGeom, eyeMat);
                eyeR.position.set(0.3, 2.3, 0.7);
                group.add(eyeR);
                const pupilR = new THREE.Mesh(new THREE.SphereGeometry(0.07), pupilMat);
                pupilR.position.set(0.3, 2.3, 0.85);
                group.add(pupilR);
            }
            else if (bossId === 'dragon_lair') {
                const bodyGeom = new THREE.CylinderGeometry(1.2, 1.2, 2.5, 8);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xaa4422, emissive: 0x331100 });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 1.2;
                group.add(body);

                const neckGeom = new THREE.CylinderGeometry(0.6, 0.8, 1.5);
                const neck = new THREE.Mesh(neckGeom, bodyMat);
                neck.position.set(0, 2.2, 0.5);
                neck.rotation.x = 0.3;
                group.add(neck);

                const headGeom = new THREE.ConeGeometry(0.7, 1, 6);
                const headMat = new THREE.MeshStandardMaterial({ color: 0xcc5533 });
                const head = new THREE.Mesh(headGeom, headMat);
                head.position.set(0, 3.2, 1.2);
                head.rotation.x = -0.2;
                group.add(head);

                const wingGeom = new THREE.ConeGeometry(1.2, 0.2, 4);
                const wingMat = new THREE.MeshStandardMaterial({ color: 0x993322 });
                const wingL = new THREE.Mesh(wingGeom, wingMat);
                wingL.position.set(-1.2, 1.8, 0);
                wingL.rotation.z = 0.3;
                wingL.rotation.y = -0.2;
                group.add(wingL);
                const wingR = wingL.clone();
                wingR.position.set(1.2, 1.8, 0);
                wingR.rotation.z = -0.3;
                wingR.rotation.y = 0.2;
                group.add(wingR);

                const tailGeom = new THREE.ConeGeometry(0.5, 1.5, 4);
                const tail = new THREE.Mesh(tailGeom, bodyMat);
                tail.position.set(0, 0.5, -1.5);
                tail.rotation.x = 0.5;
                group.add(tail);
            }
            else if (bossId === 'lich_castle') {
                const bodyGeom = new THREE.CylinderGeometry(0.8, 1.0, 3, 6);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0x557799, emissive: 0x113344 });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 1.5;
                group.add(body);

                const headGeom = new THREE.SphereGeometry(0.7, 6);
                const headMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
                const head = new THREE.Mesh(headGeom, headMat);
                head.position.y = 3.0;
                group.add(head);

                const socketGeom = new THREE.SphereGeometry(0.2);
                const socketMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
                const socketL = new THREE.Mesh(socketGeom, socketMat);
                socketL.position.set(-0.3, 3.1, 0.6);
                group.add(socketL);
                const socketR = socketL.clone();
                socketR.position.set(0.3, 3.1, 0.6);
                group.add(socketR);

                const glowGeom = new THREE.SphereGeometry(0.1);
                const glowMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x004444 });
                const glowL = new THREE.Mesh(glowGeom, glowMat);
                glowL.position.set(-0.3, 3.1, 0.8);
                group.add(glowL);
                const glowR = glowL.clone();
                glowR.position.set(0.3, 3.1, 0.8);
                group.add(glowR);

                const staffGeom = new THREE.CylinderGeometry(0.1, 0.1, 3);
                const staffMat = new THREE.MeshStandardMaterial({ color: 0x886644 });
                const staff = new THREE.Mesh(staffGeom, staffMat);
                staff.position.set(1.2, 2.0, 0.5);
                staff.rotation.z = 0.2;
                group.add(staff);
                const staffTopGeom = new THREE.SphereGeometry(0.3);
                const staffTopMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 });
                const staffTop = new THREE.Mesh(staffTopGeom, staffTopMat);
                staffTop.position.set(1.2, 3.5, 0.5);
                group.add(staffTop);
            }

            group.scale.set(0.8, 0.8, 0.8);
            group.position.y = 1.5;
            return group;
        }

        // --- –ó–ê–ì–†–£–ó–ö–ê –ò–ù–§–û–†–ú–ê–¶–ò–ò –û –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ï ---
        async function loadUser() {
            const data = await apiCall('user');
            if (!data) return;

            goldSpan.textContent = data.gold;
            updateExpBar(data.level, data.exp);
            updateInventoryDisplay(data.inventory);
            activeToolSpan.textContent = data.active_tool || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';

            if (data.boss_progress) {
                let found = false;
                for (let i = 0; i < BOSS_IDS.length; i++) {
                    const bid = BOSS_IDS[i];
                    const prog = data.boss_progress[bid];
                    if (prog && !prog.defeated) {
                        currentBossIndex = i;
                        currentBossId = bid;
                        found = true;
                        break;
                    }
                }
                if (!found && BOSS_IDS.length > 0) {
                    currentBossIndex = 0;
                    currentBossId = BOSS_IDS[0];
                }
                // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º –±–æ—Å—Å–µ, –Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ Three.js –≥–æ—Ç–æ–≤
                if (threeReady) {
                    loadBossInfo(currentBossId);
                } else {
                    // –ï—Å–ª–∏ –µ—â—ë –Ω–µ –≥–æ—Ç–æ–≤, –∂–¥—ë–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
                    const waitForThree = setInterval(() => {
                        if (threeReady) {
                            clearInterval(waitForThree);
                            loadBossInfo(currentBossId);
                        }
                    }, 100);
                }
            }
        }

        // --- –ó–ê–ì–†–£–ó–ö–ê –ò–ù–§–û–†–ú–ê–¶–ò–ò –û –ë–û–°–°–ï –ò –û–ë–ù–û–í–õ–ï–ù–ò–ï –ú–û–î–ï–õ–ò ---
        async function loadBossInfo(bid) {
            const data = await apiCall(`boss/${bid}`);
            if (data) {
                bossNameSpan.textContent = BOSS_NAMES[bid] || bid;
                updateBossHealth(data.current_health, data.max_health);
                bossHealthDiv.style.display = 'block';

                if (bossGroup && threeReady) {
                    // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é –º–æ–¥–µ–ª—å
                    while(bossGroup.children.length > 0) {
                        bossGroup.remove(bossGroup.children[0]);
                    }
                    // –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é
                    const newBoss = createBossModel(bid);
                    if (newBoss) {
                        bossGroup.add(newBoss);
                        console.log('Boss model added for', bid);
                    } else {
                        console.error('Failed to create boss model');
                    }
                } else {
                    console.warn('bossGroup not ready, cannot create model');
                }

                updateBossNavigation();
            }
        }

        // --- –ù–ê–í–ò–ì–ê–¶–ò–Ø –ü–û –ë–û–°–°–ê–ú ---
        function updateBossNavigation() {
            bossIndexSpan.textContent = `${currentBossIndex+1}/${BOSS_IDS.length}`;
            document.getElementById('prev-boss').classList.toggle('disabled', currentBossIndex === 0);
            document.getElementById('next-boss').classList.toggle('disabled', currentBossIndex === BOSS_IDS.length-1);
        }

        // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø 3D ---
        async function init3D() {
            const THREE = await import('three');
            const { OrbitControls } = await import('https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);

            camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
            camera.position.set(8, 6, 12);
            camera.lookAt(0, 1, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI/2;
            controls.target.set(0, 1, 0);

            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambient = new THREE.AmbientLight(0x404060);
            scene.add(ambient);
            const light1 = new THREE.DirectionalLight(0xffffff, 1);
            light1.position.set(5, 10, 7);
            scene.add(light1);
            const light2 = new THREE.DirectionalLight(0xffaa88, 0.5);
            light2.position.set(-5, 5, -5);
            scene.add(light2);

            // –ü–æ–ª
            const gridHelper = new THREE.GridHelper(20, 20, 0xaaaaaa, 0x444444);
            gridHelper.position.y = 0;
            scene.add(gridHelper);

            // –ö—É–±—ã-—Ä–µ—Å—É—Ä—Å—ã
            const positions = [
                [-3, 1.5, -2],
                [ 3, 1.5, -2],
                [ 0, 1.5,  2],
                [-2, 1.5,  3],
                [ 2, 1.5,  3]
            ];
            positions.forEach((pos, i) => {
                const geom = new THREE.BoxGeometry(2, 2, 2);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: i === 0 ? 0xffaa00 : i === 1 ? 0xcc8800 : i === 2 ? 0xaaaaaa : i === 3 ? 0x44aa88 : 0x8844aa,
                    emissive: 0x222222,
                    roughness: 0.3,
                    metalness: 0.1
                });
                const cube = new THREE.Mesh(geom, mat);
                cube.position.set(pos[0], pos[1], pos[2]);
                cube.userData = { type: 'resource', id: i };
                scene.add(cube);
                cubes.push(cube);
            });

            // –ì—Ä—É–ø–ø–∞ –¥–ª—è –±–æ—Å—Å–∞
            bossGroup = new THREE.Group();
            scene.add(bossGroup);

            threeReady = true; // —Ç–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –º–æ–¥–µ–ª–∏
            console.log('Three.js ready');

            // –†—ç–π–∫–∞—Å—Ç–µ—Ä
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            function onTouchStart(event) {
                event.preventDefault();
                const touch = event.touches[0];
                if (!touch) return;
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([...cubes, ...bossGroup.children]);

                if (intersects.length > 0) {
                    const hit = intersects[0].object;
                    if (hit.userData.type === 'resource') {
                        audioClick.currentTime = 0;
                        audioClick.play().catch(() => {});
                        apiCall('click', 'POST', { resourceId: hit.userData.id }).then(data => {
                            if (data) {
                                goldSpan.textContent = data.new_gold;
                                hudExp.textContent = data.new_exp;
                                updateInventoryDisplay(data.inventory);
                                showSuccess(`+${data.gold}üí∞`);
                                loadUser();
                            }
                        });
                    } else if (hit.parent === bossGroup || bossGroup.children.includes(hit)) {
                        attackBoss();
                    }
                }
            }

            function onClick(event) {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([...cubes, ...bossGroup.children]);

                if (intersects.length > 0) {
                    const hit = intersects[0].object;
                    if (hit.userData.type === 'resource') {
                        audioClick.currentTime = 0;
                        audioClick.play().catch(() => {});
                        apiCall('click', 'POST', { resourceId: hit.userData.id }).then(data => {
                            if (data) {
                                goldSpan.textContent = data.new_gold;
                                hudExp.textContent = data.new_exp;
                                updateInventoryDisplay(data.inventory);
                                showSuccess(`+${data.gold}üí∞`);
                                loadUser();
                            }
                        });
                    } else if (hit.parent === bossGroup || bossGroup.children.includes(hit)) {
                        attackBoss();
                    }
                }
            }

            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('click', onClick);

            // –ê–Ω–∏–º–∞—Ü–∏—è
            function animate() {
                cubes.forEach(c => c.rotation.y += 0.01);

                if (bossGroup && bossGroup.children.length > 0) {
                    const bossId = currentBossId;
                    if (bossId === 'goblin_king') {
                        bossGroup.position.y = 1.5 + Math.sin(Date.now() * 0.003) * 0.1;
                    } else if (bossId === 'dragon_lair') {
                        bossGroup.rotation.y += 0.005;
                    } else if (bossId === 'lich_castle') {
                        bossGroup.rotation.y += 0.002;
                    }
                }

                controls.update();
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = innerWidth/innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
            });
        }

        // --- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ù–ê–í–ò–ì–ê–¶–ò–ò ---
        document.getElementById('prev-boss').addEventListener('click', () => {
            if (currentBossIndex > 0) {
                currentBossIndex--;
                currentBossId = BOSS_IDS[currentBossIndex];
                loadBossInfo(currentBossId);
            }
        });
        document.getElementById('next-boss').addEventListener('click', () => {
            if (currentBossIndex < BOSS_IDS.length-1) {
                currentBossIndex++;
                currentBossId = BOSS_IDS[currentBossIndex];
                loadBossInfo(currentBossId);
            }
        });

        // --- –ê–¢–ê–ö–ê –ù–ê –ë–û–°–°–ê ---
        async function attackBoss() {
            if (isAttacking) return;
            if (!currentBossId) {
                showError('–ë–æ—Å—Å –Ω–µ –≤—ã–±—Ä–∞–Ω');
                return;
            }

            isAttacking = true;
            if (bossGroup.children.length > 0) {
                bossGroup.scale.set(0.9, 0.9, 0.9);
                setTimeout(() => bossGroup.scale.set(0.8, 0.8, 0.8), 150);
            }
            audioBossHit.currentTime = 0;
            audioBossHit.play().catch(() => {});

            try {
                const data = await apiCall('boss/attack', 'POST', { boss_id: currentBossId });
                if (!data) return;

                if (data.error) {
                    showError(data.error);
                    return;
                }

                if (data.new_gold !== undefined) goldSpan.textContent = data.new_gold;
                if (data.new_exp !== undefined) hudExp.textContent = data.new_exp;
                if (data.inventory) updateInventoryDisplay(data.inventory);

                if (data.current_health !== undefined && data.max_health !== undefined) {
                    updateBossHealth(data.current_health, data.max_health);
                    createHitParticles(bossGroup.position.clone());
                }

                if (data.defeated) {
                    audioVictory.currentTime = 0;
                    audioVictory.play().catch(() => {});
                    showLoot(data.loot ? data.loot : '–ù–∞–≥—Ä–∞–¥–∞ –ø–æ–ª—É—á–µ–Ω–∞!');
                    bossGroup.visible = false;
                    bossHealthDiv.style.display = 'none';
                } else {
                    showSuccess('–£–¥–∞—Ä!');
                }

                loadUser();
            } catch (e) {
                console.error(e);
            } finally {
                isAttacking = false;
            }
        }

        // --- –ß–ê–°–¢–ò–¶–´ –ü–†–ò –£–î–ê–†–ï ---
        function createHitParticles(position) {
            if (!scene) return;
            const particleCount = 15;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                positions[i*3] = position.x;
                positions[i*3+1] = position.y;
                positions[i*3+2] = position.z;
                colors[i*3] = 1;
                colors[i*3+1] = 0.3 + Math.random()*0.3;
                colors[i*3+2] = 0.1;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({ size: 0.2, vertexColors: true, transparent: true });
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            const startTime = performance.now();
            function animateParticles() {
                const elapsed = performance.now() - startTime;
                if (elapsed > 500) {
                    scene.remove(particles);
                    return;
                }
                const positionsAttr = geometry.attributes.position;
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    positionsAttr.array[i*3] += Math.cos(angle) * 0.05;
                    positionsAttr.array[i*3+1] += Math.sin(angle) * 0.05;
                    positionsAttr.array[i*3+2] += (Math.random() - 0.5) * 0.05;
                }
                positionsAttr.needsUpdate = true;
                requestAnimationFrame(animateParticles);
            }
            animateParticles();
        }

        // --- –°–¢–ê–†–¢ ---
        document.getElementById('test-button').addEventListener('click', () => {
            apiCall('click', 'POST', { resourceId: 0 }).then(data => {
                if (data) {
                    goldSpan.textContent = data.new_gold;
                    hudExp.textContent = data.new_exp;
                    updateInventoryDisplay(data.inventory);
                    loadUser();
                }
            });
        });

        // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é 3D –∏ –∑–∞–≥—Ä—É–∑–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        init3D();
        loadUser();
    </script>
</body>
</html>
