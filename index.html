<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–®–∞—Ö—Ç—ë—Ä—Å–∫–∞—è –≥–ª—É–±–∏–Ω–∞ 3D</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #hud {
        position: absolute;
        top: 10px;
        left: 10px;
        right: 220px;
        color: white;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 8px;
        z-index: 200;
        pointer-events: none;
        word-wrap: break-word;
    }
    #boss-health {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 200px;
        color: white;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 8px;
        z-index: 150;
        display: none;
        pointer-events: none;
    }
    .health-bar {
        width: 100%;
        height: 20px;
        background-color: #333;
        border-radius: 10px;
        overflow: hidden;
        margin-top: 5px;
    }
    .health-fill {
        height: 100%;
        background-color: #f44;
        width: 100%;
        transition: width 0.2s;
    }
    #debug-info {
        position: absolute;
        bottom: 80px;
        left: 10px;
        right: 10px;
        color: white;
        background: rgba(0,0,0,0.9);
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        font-size: 14px;
        white-space: pre-wrap;
        word-break: break-word;
        border: 2px solid yellow;
        max-height: 200px;
        overflow: auto;
    }
    #error-message {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        color: red;
        background: rgba(0,0,0,0.9);
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        font-size: 14px;
        white-space: pre-wrap;
        word-break: break-word;
        border: 2px solid red;
    }
    #success-message {
        position: absolute;
        bottom: 60px;
        left: 10px;
        right: 10px;
        color: #0f0;
        background: rgba(0,0,0,0.9);
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        font-size: 14px;
        white-space: pre-wrap;
        word-break: break-word;
        border: 2px solid #0f0;
        display: none;
    }
    #debug-status {
        position: absolute;
        top: 70px;
        left: 10px;
        color: yellow;
        background: rgba(0,0,0,0.5);
        padding: 5px;
        border-radius: 3px;
        font-size: 12px;
        z-index: 300;
        pointer-events: none;
    }
</style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="hud">
        <div>üí∞ –ó–æ–ª–æ—Ç–æ: <span id="gold">0</span></div>
        <div>‚ú® –û–ø—ã—Ç: <span id="exp">0</span></div>
        <div>üì¶ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å: <span id="inventory">‚Äî</span></div>
    </div>
    <div id="boss-health">
        <div>üëæ –ë–æ—Å—Å: <span id="boss-name"></span></div>
        <div class="health-bar"><div class="health-fill" id="boss-health-fill" style="width:100%"></div></div>
        <div><span id="boss-current-health">0</span>/<span id="boss-max-health">0</span></div>
    </div>
    <div id="debug-info" style="display: none;"></div>
    <div id="error-message" style="display: none;"></div>
    <div id="success-message" style="display: none;"></div>
    <div id="debug-status">‚öôÔ∏è –ó–∞–≥—Ä—É–∑–∫–∞...</div>

    <script type="module">
        // --- –ù–ê–°–¢–†–û–ô–ö–ê: –ê–¥—Ä–µ—Å –≤–∞—à–µ–≥–æ –±–æ—Ç–∞ –Ω–∞ Render ---
        const API_BASE_URL = 'https://telegram-clicker-bot-zi6c.onrender.com';
        // ---------------------------------------------

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –º–æ–¥—É–ª—è
        let currentBossId = null;
        let isAttacking = false;
        let bossMesh = null;
        let cubes = [];

        // –≠–ª–µ–º–µ–Ω—Ç—ã –æ—Ç–ª–∞–¥–∫–∏
        const debugStatus = document.getElementById('debug-status');

        function setDebugStatus(text) {
            debugStatus.textContent = '‚öôÔ∏è ' + text;
        }

        // –û—Ç–ª–∞–¥–∫–∞
        function debugLog(msg) {
            const el = document.getElementById('debug-info');
            el.style.display = 'block';
            el.innerHTML = msg + '<br>' + el.innerHTML;
            console.log(msg);
        }

        function showError(msg) {
            const el = document.getElementById('error-message');
            el.style.display = 'block';
            el.innerHTML = msg;
        }

        function showSuccess(msg) {
            const el = document.getElementById('success-message');
            el.style.display = 'block';
            el.innerHTML = msg;
            setTimeout(() => { el.style.display = 'none'; }, 2000);
        }

        // Telegram
        let tg;
        try {
            tg = window.Telegram.WebApp;
            tg.ready();
            tg.expand();
        } catch (e) {
            tg = { ready: () => {}, expand: () => {}, HapticFeedback: { impactOccurred: () => {} }, initData: "" };
        }
        const initData = tg.initData;
        debugLog('initData: ' + (initData ? initData.substring(0,50) + '...' : '–Ω–µ—Ç'));

        // API —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π –æ—Ç–ª–∞–¥–∫–æ–π
        async function apiCall(endpoint, method = 'GET', body = null) {
            const headers = { 'Content-Type': 'application/json' };
            if (initData) headers['X-Telegram-Init-Data'] = initData;
            const options = { method, headers };
            if (body) options.body = JSON.stringify(body);
            
            const logMsg = `‚û°Ô∏è –ó–∞–ø—Ä–æ—Å ${method} /api/${endpoint} ` + (body ? `—Ç–µ–ª–æ: ${JSON.stringify(body)}` : '');
            debugLog(logMsg);
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                options.signal = controller.signal;
                
                const response = await fetch(`${API_BASE_URL}/api/${endpoint}`, options);
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText.substring(0,100)}`);
                }
                const json = await response.json();
                debugLog(`‚úÖ –û—Ç–≤–µ—Ç –æ—Ç ${endpoint}: ${JSON.stringify(json, null, 2)}`);
                return json;
            } catch (e) {
                const errorMsg = `‚ùå –û—à–∏–±–∫–∞ API ${endpoint}: ${e.message}`;
                debugLog(errorMsg);
                showError(errorMsg);
                return null;
            }
        }

        // –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ —á—Ç–µ–Ω–∏–µ –∑–¥–æ—Ä–æ–≤—å—è –∏–∑ –æ–±—ä–µ–∫—Ç–∞
        function extractBossHealth(data) {
            let current = data.current_health ?? data.health ?? data.hp ?? data.boss?.health ?? data.boss_health ?? 0;
            let max = data.max_health ?? data.maxHealth ?? data.max_hp ?? data.max ?? data.boss?.max_health ?? data.boss_max_health ?? 1000;
            return { current, max };
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–¥–æ—Ä–æ–≤—å—è –±–æ—Å—Å–∞ –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
        function updateBossHealth(current, max) {
            document.getElementById('boss-current-health').textContent = current;
            document.getElementById('boss-max-health').textContent = max;
            const percent = max > 0 ? (current / max) * 100 : 0;
            document.getElementById('boss-health-fill').style.width = percent + '%';
        }

        // –°–∫—Ä—ã—Ç—å –±–æ—Å—Å–∞ –∏ –µ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        function hideBoss() {
            if (bossMesh) bossMesh.visible = false;
            document.getElementById('boss-health').style.display = 'none';
        }

        // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –∞—Ç–∞–∫–∏ (–º–∏–≥–∞–Ω–∏–µ)
        function flashBoss() {
            if (!bossMesh) return;
            bossMesh.material.emissive.setHex(0x880000);
            setTimeout(() => {
                if (bossMesh) bossMesh.material.emissive.setHex(0x440000);
            }, 100);
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è (–≤—ã–Ω–µ—Å–µ–Ω–æ –≤ –æ—Ç–¥–µ–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é)
        function updateInventoryDisplay(inventoryObj) {
            if (!inventoryObj) {
                document.getElementById('inventory').textContent = '‚Äî';
                return;
            }
            const entries = Object.entries(inventoryObj).filter(([,v]) => v > 0);
            if (entries.length === 0) {
                document.getElementById('inventory').textContent = '–ø—É—Å—Ç–æ';
            } else {
                document.getElementById('inventory').textContent = entries.map(([k,v]) => `${k}:${v}`).join(', ');
            }
        }

        // –ê—Ç–∞–∫–∞ –Ω–∞ –±–æ—Å—Å–∞ (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
        async function attackBoss() {
            setDebugStatus(`–ê—Ç–∞–∫–∞? isAttacking=${isAttacking}, currentBossId=${currentBossId}`);
            
            if (isAttacking) {
                debugLog('‚è≥ –ê—Ç–∞–∫–∞ —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º');
                return;
            }
            if (!currentBossId) {
                const errMsg = '‚ö†Ô∏è –ë–æ—Å—Å –Ω–µ –≤—ã–±—Ä–∞–Ω (currentBossId = null)';
                showError(errMsg);
                debugLog(errMsg);
                return;
            }

            isAttacking = true;
            flashBoss();
            setDebugStatus(`–ê—Ç–∞–∫—É—é –±–æ—Å—Å–∞ ${currentBossId}...`);

            try {
                debugLog(`‚öîÔ∏è –ê—Ç–∞–∫—É–µ–º –±–æ—Å—Å–∞ ${currentBossId}`);
                const data = await apiCall('boss/attack', 'POST', { boss_id: currentBossId });
                if (!data) {
                    isAttacking = false;
                    setDebugStatus('–ê—Ç–∞–∫–∞: –Ω–µ—Ç –æ—Ç–≤–µ—Ç–∞');
                    return;
                }

                // –ï—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª —è–≤–Ω—É—é –æ—à–∏–±–∫—É
                if (data.error) {
                    showError(data.error);
                    setDebugStatus('–ê—Ç–∞–∫–∞: –æ—à–∏–±–∫–∞ - ' + data.error);
                    isAttacking = false;
                    return;
                }

                // –£—Å–ø–µ—Ö: –æ–±–Ω–æ–≤–ª—è–µ–º —Ä–µ—Å—É—Ä—Å—ã
                if (data.new_gold !== undefined) {
                    document.getElementById('gold').textContent = data.new_gold;
                }
                if (data.new_exp !== undefined) {
                    document.getElementById('exp').textContent = data.new_exp;
                }

                // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å
                if (data.inventory) {
                    updateInventoryDisplay(data.inventory);
                }

                // –û–±–Ω–æ–≤–ª—è–µ–º –∑–¥–æ—Ä–æ–≤—å–µ –±–æ—Å—Å–∞
                const { current, max } = extractBossHealth(data);
                if (current !== undefined && max !== undefined) {
                    updateBossHealth(current, max);
                    if (current <= 0) {
                        hideBoss();
                        showSuccess('üéâ –ë–æ—Å—Å –ø–æ–≤–µ—Ä–∂–µ–Ω!');
                    } else {
                        showSuccess('üí• –£–¥–∞—Ä!');
                    }
                    setDebugStatus(`–ê—Ç–∞–∫–∞ —É—Å–ø–µ—à–Ω–∞: –∑–¥–æ—Ä–æ–≤—å–µ ${current}/${max}`);
                } else {
                    debugLog('‚ö†Ô∏è –í –æ—Ç–≤–µ—Ç–µ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –∑–¥–æ—Ä–æ–≤—å–µ –±–æ—Å—Å–∞');
                    setDebugStatus('–ê—Ç–∞–∫–∞: –Ω–µ—Ç –∑–¥–æ—Ä–æ–≤—å—è –≤ –æ—Ç–≤–µ—Ç–µ');
                }
            } catch (e) {
                // –æ—à–∏–±–∫–∞ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞ –≤ apiCall
                setDebugStatus('–ê—Ç–∞–∫–∞: –∏—Å–∫–ª—é—á–µ–Ω–∏–µ');
            } finally {
                isAttacking = false;
            }
        }

        // –ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        async function loadUser() {
            setDebugStatus('–ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è...');
            const data = await apiCall('user');
            if (!data) {
                setDebugStatus('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è');
                return;
            }
            document.getElementById('gold').textContent = data.gold;
            document.getElementById('exp').textContent = data.exp;
            updateInventoryDisplay(data.inventory);
            
            if (data.boss_progress) {
                for (let [bid, prog] of Object.entries(data.boss_progress)) {
                    if (!prog.defeated) {
                        document.getElementById('boss-health').style.display = 'block';
                        document.getElementById('boss-name').textContent = bid;
                        loadBossInfo(bid);
                        break;
                    }
                }
            } else {
                setDebugStatus('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –±–æ—Å—Å–∞—Ö');
            }
        }

        async function loadBossInfo(bid) {
            setDebugStatus(`–ó–∞–≥—Ä—É–∑–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–æ—Å—Å–µ ${bid}...`);
            const data = await apiCall(`boss/${bid}`);
            if (data) {
                currentBossId = bid;
                const { current, max } = extractBossHealth(data);
                updateBossHealth(current, max);
                if (bossMesh) bossMesh.visible = true;
                debugLog(`üê≤ –ë–æ—Å—Å ${bid} –∑–∞–≥—Ä—É–∂–µ–Ω: –∑–¥–æ—Ä–æ–≤—å–µ ${current}/${max}`);
                setDebugStatus(`–ë–æ—Å—Å ${bid}: ${current}/${max}`);
            } else {
                setDebugStatus(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –±–æ—Å—Å–∞ ${bid}`);
            }
        }

        // 3D —Å—Ü–µ–Ω–∞
        import('three').then((THREE) => {
            import('https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js').then(({ OrbitControls }) => {
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x111122);
                const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
                camera.position.set(8, 6, 12);
                camera.lookAt(0, 1, 0);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(innerWidth, innerHeight);
                document.body.appendChild(renderer.domElement);
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.maxPolarAngle = Math.PI/2;
                controls.target.set(0, 1, 0);

                // –û—Å–≤–µ—â–µ–Ω–∏–µ
                const ambient = new THREE.AmbientLight(0x404060);
                scene.add(ambient);
                const light1 = new THREE.DirectionalLight(0xffffff, 1);
                light1.position.set(5, 10, 7);
                scene.add(light1);
                const light2 = new THREE.DirectionalLight(0xffaa88, 0.5);
                light2.position.set(-5, 5, -5);
                scene.add(light2);

                // –ü–æ–ª —Å —Å–µ—Ç–∫–æ–π
                const gridHelper = new THREE.GridHelper(20, 20, 0xaaaaaa, 0x444444);
                gridHelper.position.y = 0;
                scene.add(gridHelper);

                // –ö—É–±—ã-—Ä–µ—Å—É—Ä—Å—ã
                const positions = [
                    [-3, 1.5, -2],
                    [ 3, 1.5, -2],
                    [ 0, 1.5,  2],
                    [-2, 1.5,  3],
                    [ 2, 1.5,  3]
                ];
                positions.forEach((pos, i) => {
                    const geom = new THREE.BoxGeometry(2, 2, 2);
                    const mat = new THREE.MeshStandardMaterial({ 
                        color: i === 0 ? 0xffaa00 : i === 1 ? 0xcc8800 : i === 2 ? 0xaaaaaa : i === 3 ? 0x44aa88 : 0x8844aa,
                        emissive: 0x222222,
                        roughness: 0.3,
                        metalness: 0.1
                    });
                    const cube = new THREE.Mesh(geom, mat);
                    cube.position.set(pos[0], pos[1], pos[2]);
                    cube.userData = { type: 'resource', id: i };
                    scene.add(cube);
                    cubes.push(cube);
                });

                // –ë–æ—Å—Å
                const bossGeom = new THREE.ConeGeometry(1.5, 3, 8);
                const bossMat = new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0x440000 });
                const boss = new THREE.Mesh(bossGeom, bossMat);
                boss.position.set(0, 1.5, 0);
                boss.userData = { type: 'boss' };
                boss.visible = false;
                scene.add(boss);
                bossMesh = boss;

                // –†—ç–π–∫–∞—Å—Ç–µ—Ä
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–∞—Å–∞–Ω–∏–π –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö
                function onTouchStart(event) {
                    event.preventDefault();
                    const touch = event.touches[0];
                    if (!touch) return;
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    debugLog(`üì± –ö–∞—Å–∞–Ω–∏–µ: —ç–∫—Ä–∞–Ω (${touch.clientX},${touch.clientY}) -> –Ω–æ—Ä–º (${mouse.x.toFixed(2)}, ${mouse.y.toFixed(2)})`);

                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects([...cubes, bossMesh]);
                    
                    if (intersects.length > 0) {
                        const hit = intersects[0].object;
                        debugLog(`üéØ –ü–æ–ø–∞–ª –≤ –æ–±—ä–µ–∫—Ç: type=${hit.userData.type}, id=${hit.userData.id}, dist=${intersects[0].distance.toFixed(2)}`);
                        
                        if (hit.userData.type === 'resource') {
                            apiCall('click', 'POST', { resourceId: hit.userData.id }).then(data => {
                                if (data) {
                                    document.getElementById('gold').textContent = data.new_gold;
                                    document.getElementById('exp').textContent = data.new_exp;
                                    updateInventoryDisplay(data.inventory);
                                    showSuccess(`+${data.gold}üí∞`);
                                }
                            });
                        } else if (hit.userData.type === 'boss') {
                            debugLog('üëæ –í—ã–∑–≤–∞–Ω –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞—Ç–∞–∫–∏ –±–æ—Å—Å–∞');
                            attackBoss();
                        }
                    } else {
                        debugLog('‚ùå –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –Ω–µ—Ç');
                    }
                }

                // –î–ª—è –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ –æ—Å—Ç–∞–≤–ª—è–µ–º click
                function onClick(event) {
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    debugLog(`üñ±Ô∏è –ö–ª–∏–∫: —ç–∫—Ä–∞–Ω (${event.clientX},${event.clientY}) -> –Ω–æ—Ä–º (${mouse.x.toFixed(2)}, ${mouse.y.toFixed(2)})`);

                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects([...cubes, bossMesh]);

                    if (intersects.length > 0) {
                        const hit = intersects[0].object;
                        debugLog(`üéØ –ü–æ–ø–∞–ª –≤ –æ–±—ä–µ–∫—Ç: type=${hit.userData.type}, id=${hit.userData.id}, dist=${intersects[0].distance.toFixed(2)}`);

                        if (hit.userData.type === 'resource') {
                            apiCall('click', 'POST', { resourceId: hit.userData.id }).then(data => {
                                if (data) {
                                    document.getElementById('gold').textContent = data.new_gold;
                                    document.getElementById('exp').textContent = data.new_exp;
                                    updateInventoryDisplay(data.inventory);
                                    showSuccess(`+${data.gold}üí∞`);
                                }
                            });
                        } else if (hit.userData.type === 'boss') {
                            debugLog('üëæ –í—ã–∑–≤–∞–Ω –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞—Ç–∞–∫–∏ –±–æ—Å—Å–∞');
                            attackBoss();
                        }
                    } else {
                        debugLog('‚ùå –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π –Ω–µ—Ç');
                    }
                }

                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('click', onClick);

                // –ê–Ω–∏–º–∞—Ü–∏—è
                function animate() {
                    cubes.forEach(c => c.rotation.y += 0.01);
                    if (bossMesh && bossMesh.visible) bossMesh.rotation.y += 0.01;
                    controls.update();
                    renderer.render(scene, camera);
                    requestAnimationFrame(animate);
                }
                animate();

                // –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
                loadUser();

                window.addEventListener('resize', () => {
                    camera.aspect = innerWidth/innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(innerWidth, innerHeight);
                });
            });
        });
    </script>
</body>
</html>
