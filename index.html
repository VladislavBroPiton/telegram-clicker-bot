<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–®–∞—Ö—Ç—ë—Ä—Å–∫–∞—è –≥–ª—É–±–∏–Ω–∞ 3D</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 8px;
            z-index: 100;
            pointer-events: none;
        }
        #boss-health {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 8px;
            z-index: 100;
            display: none;
        }
        .health-bar {
            width: 200px;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }
        .health-fill {
            height: 100%;
            background-color: #f44;
            width: 100%;
            transition: width 0.2s;
        }
        #error-message {
            position: absolute;
            bottom: 60px;
            left: 10px;
            right: 10px;
            color: red;
            background: rgba(0,0,0,0.9);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 14px;
            white-space: pre-wrap;
            word-break: break-word;
            border: 2px solid red;
        }
        #debug {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: lime;
            background: black;
            padding: 5px;
            font-size: 12px;
            z-index: 300;
            max-width: 90%;
            word-break: break-all;
        }
        #testButton {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
            background: red;
            color: white;
            padding: 10px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="hud">
        <div>üí∞ –ó–æ–ª–æ—Ç–æ: <span id="gold">0</span></div>
        <div>‚ú® –û–ø—ã—Ç: <span id="exp">0</span></div>
        <div>üì¶ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å: <span id="inventory">‚Äî</span></div>
    </div>
    <div id="boss-health">
        <div>üëæ –ë–æ—Å—Å: <span id="boss-name"></span></div>
        <div class="health-bar"><div class="health-fill" id="boss-health-fill" style="width:100%"></div></div>
        <div><span id="boss-current-health">0</span>/<span id="boss-max-health">0</span></div>
    </div>
    <div id="error-message" style="display: none;"></div>
    <div id="debug"></div>
    <button id="testButton">–¢–µ—Å—Ç –∫–ª–∏–∫–∞</button>

    <script type="module">
        // --- –ù–ê–°–¢–†–û–ô–ö–ê: –ê–¥—Ä–µ—Å –≤–∞—à–µ–≥–æ –±–æ—Ç–∞ –Ω–∞ Render ---
        const API_BASE_URL = 'https://telegram-clicker-bot-zi6c.onrender.com'; // <--- –ò–ó–ú–ï–ù–ò–¢–ï –≠–¢–û!
        // ---------------------------------------------

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∫–∞–∑–∞ –æ—à–∏–±–æ–∫
        function showError(msg) {
            const el = document.getElementById('error-message');
            el.style.display = 'block';
            el.innerHTML = msg;
        }

        // Telegram
        let tg;
        try {
            tg = window.Telegram.WebApp;
            tg.ready();
            tg.expand();
        } catch (e) {
            tg = { ready: () => {}, expand: () => {}, HapticFeedback: { impactOccurred: () => {} }, initData: "" };
        }
        const initData = tg.initData;
        document.getElementById('debug').innerHTML = 'initData: ' + (initData ? initData.substring(0,50) + '...' : '–Ω–µ—Ç');

        // API –≤—ã–∑–æ–≤
        async function apiCall(endpoint, method = 'GET', body = null) {
            const headers = { 'Content-Type': 'application/json' };
            if (initData) headers['X-Telegram-Init-Data'] = initData;
            const options = { method, headers };
            if (body) options.body = JSON.stringify(body);
            try {
                const response = await fetch(`${API_BASE_URL}/api/${endpoint}`, options);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response.json();
            } catch (e) {
                showError(`–û—à–∏–±–∫–∞ API ${endpoint}: ${e.message}`);
                return null;
            }
        }

        // –¢–µ—Å—Ç–æ–≤–∞—è –∫–Ω–æ–ø–∫–∞
        document.getElementById('testButton').onclick = async () => {
            showError('–û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∫–ª–∏–∫–∞...');
            const data = await apiCall('click', 'POST', { resourceId: 0 });
            if (data) {
                showError(`–£—Å–ø–µ—Ö! –ó–æ–ª–æ—Ç–æ: ${data.new_gold}`);
                document.getElementById('gold').textContent = data.new_gold;
                document.getElementById('exp').textContent = data.new_exp;
            }
        };

        // –ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        async function loadUser() {
            const data = await apiCall('user');
            if (!data) return;
            document.getElementById('gold').textContent = data.gold;
            document.getElementById('exp').textContent = data.exp;
            // –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å
            const inv = Object.entries(data.inventory).filter(([,v]) => v>0).map(([k,v]) => `${k}:${v}`).join(', ');
            document.getElementById('inventory').textContent = inv || '–ø—É—Å—Ç–æ';
            if (data.boss_progress) {
                for (let [bid, prog] of Object.entries(data.boss_progress)) {
                    if (!prog.defeated) {
                        document.getElementById('boss-health').style.display = 'block';
                        document.getElementById('boss-name').textContent = bid;
                        loadBossInfo(bid);
                        break;
                    }
                }
            }
        }

        async function loadBossInfo(bid) {
            const data = await apiCall(`boss/${bid}`);
            if (data) {
                document.getElementById('boss-current-health').textContent = data.current_health;
                document.getElementById('boss-max-health').textContent = data.max_health;
                const percent = (data.current_health / data.max_health) * 100;
                document.getElementById('boss-health-fill').style.width = percent + '%';
            }
        }

        // 3D —Å—Ü–µ–Ω–∞
        import('three').then((THREE) => {
            import('https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js').then(({ OrbitControls }) => {
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x111122);
                const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
                camera.position.set(5,5,10);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(innerWidth, innerHeight);
                document.body.appendChild(renderer.domElement);
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.maxPolarAngle = Math.PI/2;

                // –û—Å–≤–µ—â–µ–Ω–∏–µ
                scene.add(new THREE.AmbientLight(0x404060));
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(1,2,1);
                scene.add(light);

                // –ü–æ–ª
                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(20,20),
                    new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 })
                );
                floor.rotation.x = -Math.PI/2;
                floor.position.y = 0;
                scene.add(floor);

                // –ö—É–±—ã-—Ä–µ—Å—É—Ä—Å—ã
                const cubes = [];
                const positions = [[-3,0.5,-3], [3,0.5,-3], [0,0.5,3], [-2,0.5,2], [2,0.5,2]];
                positions.forEach((pos, i) => {
                    const cube = new THREE.Mesh(
                        new THREE.BoxGeometry(1,1,1),
                        new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x222222 })
                    );
                    cube.position.set(pos[0], pos[1], pos[2]);
                    cube.userData = { type: 'resource', id: i };
                    scene.add(cube);
                    cubes.push(cube);
                });

                // –ë–æ—Å—Å-–∫–æ–Ω—É—Å
                const boss = new THREE.Mesh(
                    new THREE.ConeGeometry(1,2,8),
                    new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0x440000 })
                );
                boss.position.set(0,1,0);
                boss.userData = { type: 'boss' };
                boss.visible = false;
                scene.add(boss);

                // –†—ç–π–∫–∞—Å—Ç–µ—Ä
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                window.addEventListener('click', (e) => {
                    mouse.x = (e.clientX / innerWidth) * 2 - 1;
                    mouse.y = -(e.clientY / innerHeight) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects([...cubes, boss]);
                    if (intersects.length === 0) {
                        showError('–ö–ª–∏–∫ –º–∏–º–æ');
                        return;
                    }
                    const hit = intersects[0].object;
                    if (hit.userData.type === 'resource') {
                        showError(`–ö–ª–∏–∫ –ø–æ —Ä–µ—Å—É—Ä—Å—É ${hit.userData.id}`);
                        apiCall('click', 'POST', { resourceId: hit.userData.id }).then(data => {
                            if (data) {
                                document.getElementById('gold').textContent = data.new_gold;
                                document.getElementById('exp').textContent = data.new_exp;
                                // –æ–±–Ω–æ–≤–∏—Ç—å –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å
                                const inv = Object.entries(data.inventory).filter(([,v]) => v>0).map(([k,v]) => `${k}:${v}`).join(', ');
                                document.getElementById('inventory').textContent = inv || '–ø—É—Å—Ç–æ';
                            }
                        });
                    } else if (hit.userData.type === 'boss') {
                        showError('–ö–ª–∏–∫ –ø–æ –±–æ—Å—Å—É');
                        // –∑–¥–µ—Å—å –ø–æ–∑–∂–µ
                    }
                });

                // –ê–Ω–∏–º–∞—Ü–∏—è
                function animate() {
                    cubes.forEach(c => c.rotation.y += 0.005);
                    controls.update();
                    renderer.render(scene, camera);
                    requestAnimationFrame(animate);
                }
                animate();

                // –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
                loadUser();

                window.addEventListener('resize', () => {
                    camera.aspect = innerWidth/innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(innerWidth, innerHeight);
                });
            });
        });
    </script>
</body>
</html>
